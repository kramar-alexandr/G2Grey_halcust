external inner updating procedure InitUniversityCache();
external inner function Integer GetProgramMode();
external inner updating procedure AskForNewUser();
external inner updating procedure InitIdleTasks();
external inner procedure InitSysRunIdleTasks(Integer);
external inner procedure InitTXIdleTasks();
external inner updating procedure SMSWhenNotProperlyTerminated();
external inner procedure RegisterAtPresenceServer(string,Integer,Integer);

// Same GetFeatureUsage as in IntEnabCl.hal
updating procedure GetFeatureUsage(record InternetEnablerBlock IEr,Boolean automatic,string hwaddress,Integer hwport,LongInt fcnt)
begin
  area msg;
  area reply;
  record SmartAppVc SmartAppr;
  record RegisterDefinitionVc RegisterDefinitionr;
  record FunctionUsageVc FunctionUsager;
  LongInt res,pos;
  Boolean foundf;
  Integer vers;
  LongInt i,regcnt;
  record FunctionUsageVc tmpFunctionUsager;
  record FunctionUsageVc oldFunctionUsager;
  Boolean testf;
  string 200 thekey;
  string 100 comment,tempst;
  Integer timeout;
  Boolean sendf;
  
  sendf = false;
  timeout = 60;
  if (IEr.HWTimeout>0) then begin
    timeout = IEr.HWTimeout + 10;
  end;
  LogText(14689,"GetFeatureUsage");
  HTSAddInt(msg,0); // Version
  HTSAddInt(msg,IEr.RegInCountry);
  HTSAddString(msg,IEr.CustomerCode);
  HTSAddLong(msg,IEr.Contract);
  HTSAddLong(msg,IEr.EnablerRegistration);
  HTSAddInt(msg,GetProgramMode);
  HTSAddLong(msg,fcnt);
  HTSAddInt(msg,10); // Number of fields in the send call
  foundf = true;
  FunctionUsager.Function = "";
  while (LoopMain(FunctionUsager,1,foundf)) begin
    comment = "";
    SmartAppr.UUID = FunctionUsager.App;
    if (ReadFirstKey("UUID",SmartAppr,1,true)) then begin
      comment = SmartAppr.Name;
    end;
    if (blank(comment)) then begin
      RegisterDefinitionr.Name = FunctionUsager.SpecFeature;
      thekey = "MainKey:" & FunctionUsager.App;
      if (ReadFirstKey(thekey,RegisterDefinitionr,1,true)) then begin
        comment = RegisterDefinitionr.Description;
      end;
    end;
    regcnt = 0;
    RegisterDefinitionr.Name = "";
    thekey = "MainKey:" & FunctionUsager.App;
    ResetLoop(RegisterDefinitionr);
    while (LoopKey(thekey,RegisterDefinitionr,1,true)) begin
      regcnt = regcnt + 1;
    end;
    HTSAddString(msg,FunctionUsager.Function);
    HTSAddInt(msg,FunctionUsager.FunctionType);
    HTSAddString(msg,FunctionUsager.SpecFeature);
    HTSAddUUID(msg,FunctionUsager.App);
    HTSAddLong(msg,FunctionUsager.TimesUsed);
    HTSAddDate(msg,FunctionUsager.FirstUsed);
    HTSAddLong(msg,FunctionUsager.Key);
    HTSAddString(msg,comment);
    HTSAddLong(msg,regcnt);
    HTSAddString(msg,tempst);
    if (blankdate(FunctionUsager.CanUseUntil)) then begin
      sendf = true;
    end else begin
      if (FunctionUsager.CanUseUntil<AddDay(CurrentDate,10)) then begin
        sendf = true;
      end;
    end;
  end;
  if (sendf) then begin
    res = HTSAreaSend(hwaddress,hwport,"HtsGetFeatureUsage","GetFeatureUsageReply",timeout,true,msg,reply);
    LogText(0,"GetFeatureUsage = " & res);
  end;
  return;
end;

updating procedure CallGetKeyFeature()
begin
  record InternetEnablerBlock IEr;
  string 200 hwaddress;
  Integer hwport;
  LongInt fcnt;
  
  LogText(14689,"CallGetKeyFeature");
  BlockLoad(IEr);
  fcnt = CountRecords("FunctionUsageVc");
  if (false and fcnt>0) then begin
    hwaddress = IEr.HWAddress;
    hwport = IEr.HWPort;
    if (nonblank(hwaddress) and hwport>0) then begin
      GetFeatureUsage(IEr,true,hwaddress,hwport,fcnt);
    end;
  end;
  return;
end;

procedure ExportPublicIPs()
begin
  record PublicIPBlock PIPb;
  row PublicIPBlock PIPbw;
  string 200 tstr;
  Integer i,rwcnt;

  BlockLoad(PIPb);
  rwcnt = MatRowCnt(PIPb);
  if (rwcnt>0) then begin
    CreateFile("hob/serverip.dat");
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PIPb,i,PIPbw);
      tstr = PIPbw.Host;
      if (PIPbw.Port>0) then begin
         tstr = tstr & ":" & PIPbw.Port;
      end;
      ExportPadString(tstr,len(tstr)," ",false);
      NewLine;
    end;
    CloseFile;
  end;
  return;
end;

updating procedure CheckDatabaseID()
begin
  record DBERecordsBlock DBERb;
  
  BlockLoad(DBERb);
  if (nonblank(DBERb.DatabaseID)) then begin
    if (DBERb.DatabaseID!=DatabaseID) then begin
      DBERb.DBStatus = 0;
      DBERb.DatabaseID = "";
      BlockStore(DBERb);
    end;
  end;
  return;
end;

updating procedure ResetRecordStatuses()
begin
  record KPIDefVc KPIDefr;
  record KPIDefVc newKPIDefr;
  LongInt rwcnt,oldcomp,i;
  record CompaniesBlock Compb;
  row CompaniesBlock Comprw;
  
  oldcomp = CurrentCompany;
  
  DBHold;
  
  BlockLoad(Compb);
  rwcnt = MatRowCnt(Compb);
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(Compb,i,Comprw);
    if (blank(Comprw.TCPIP)) then begin
      if (SetCompanyCode(Comprw.CompCode,false)) then begin
        while (LoopMain(KPIDefr,1,true)) begin
          switch (KPIDefr.Status) begin
            case kKPIStatusInvalid:
            case kKPIStatusValid:
            case kKPIStatusInvalidCalculating:
              RecordCopy(newKPIDefr,KPIDefr);
              newKPIDefr.Status = kKPIStatusInvalid;
              RecordUpdate(KPIDefr,newKPIDefr,false);
            case kKPIStatusValidCalculating:
              RecordCopy(newKPIDefr,KPIDefr);
              newKPIDefr.Status = kKPIStatusValid;
              RecordUpdate(KPIDefr,newKPIDefr,false);
          end;
        end;
      end;
    end;
  end;  
  ResetCompany(oldcomp);

  InitUniversityCache;
  
  DBFlush;
  return;
end;

// Before Login and before the selection of the startup company. It doesn't KNOW what mode it will become
global
updating procedure OnApplicationStartup()
begin
record UserVc USr;
  
  recordnew(USr);
  
  USr.Code = "SA";
  recordinsert(USr,true);
  AskForNewUser;
  return;
end;

global
procedure InitClientIdleTasks()
begin
  date td;
  time t,startt;
  
  if (CountRecords("KPIDefVc")>0) then begin
    NewPeriodicTask2("UpdateMasterWClassonKPIsIdleTask","Master Control on KPIs Idle Task","UpdateMasterWClassOnKPIs","",120);
  end;

  startt = CurrentTime;
  td = CurrentDate;
  t = AddSeconds(startt,6);
  if (t<startt) then begin
    td = AddDay(td,1);
  end;
  NewTimedTask("UpdateMasterBanner","Update Master Control Banner","UpdateMasterBanner","first",td,t,"");
  return;
end;

// After Login or after the server has been started
global
updating procedure OnApplicationStartupComplete()
begin
  record TempBlock TMb;
  record RcVc RepSpec;
  Integer wn;
  Integer pt;

  if (CompileType!=ctWindowsCE and CompileType!=ctSeries80 and CompileType!=ctSeries60 and CompileType!=ctNokiaE90 and CompileType!=ctBPadCE and CompileType!=ctWindowsCELandscape) then begin
    asyncremote.RegisterAtPresenceServer(CurrentUser,1,1);
  end;
  if (ServerMode or SingleUserMode) then begin
    ExportPublicIPs;
    if (LastSesTerminated!=0) then begin
      SMSWhenNotProperlyTerminated;
    end;
    ResetRecordStatuses;
    InitTXIdleTasks;//Server
    InitIdleTasks;//Server
    CheckDatabaseID;//Server
    InitSysRunIdleTasks(0);//Server
  end;
  if (ClientMode or SingleUserMode) then begin
    InitClientIdleTasks;//Client
  end;

  CallGetKeyFeature;
  BlockLoad(TMb);
  pt = GetProgramMode;
  if (TMb.Deflag!=0 and IsBooks==false and pt!=typReports and pt!=typPOS and pt!=typStock and pt!=typSynchronizedPOS and pt!=typMobileRestaurant) then begin
    wn = OpenWindow("DemoCompanyWClass",0,0,"","",RepSpec);
  end;
  return;
end;

//Just before shutting down
global
procedure OnApplicationShutdown()
begin
  if (PresenceWasSuccessful) then begin
    if (ServerMode or SingleUserMode) then begin
      asyncremote.RegisterAtPresenceServer("",0,0);
    end;
    if (UserActive) and ((SingleUserMode) or (ClientMode)) then begin
      asyncremote.RegisterAtPresenceServer(CurrentUser,0,1);
    end;
  end;
  return;
end;

// Once converted, it will read one block, set one company and read one access gruop maximum, before exiting. That's fast enough.
updating procedure UpdateOldAcceeGroups()
begin
  record GlobalUserVc GlobalUserr;
  record GlobalUserVc oldGlobalUserr;
  row GlobalUserVc GlobalUserrw;
  record UserVc Userr;
  record UserVc oldUserr;
  record AccessVc Accessr;
  record AccessVc oldAccessr;
  record CompaniesBlock CompaniesRec;
  row CompaniesBlock comprw;
  Integer compnr,oldcomp;
  Integer i,rwcnt;
  Boolean foundf,foundf2,updatef;
  
  oldcomp = CurrentCompany;
  BlockLoad(CompaniesRec);
  rwcnt = MatRowCnt(CompaniesRec);
// This loops sets up the UserVc record ONLY
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CompaniesRec,i,comprw);
    if (blank(comprw.TCPIP)) then begin
      if (SetCompanyCode(comprw.CompCode,false)) then begin
        ResetLoop(Accessr);
        foundf = true;
        Accessr.Code = "";
        while (LoopMain(Accessr,1,foundf)) begin
          if (Accessr.StartLevel==2) then begin
            goto LAlreadyConverted;
          end;
          ResetLoop(Userr);
          foundf2 = true;
          Userr.Code = "";
          while (LoopMain(Userr,1,foundf2)) begin
            if (Userr.AccessGroup==Accessr.Code and Accessr.StartLevel==0 and Userr.StartLevel==0) then begin
              RecordCopy(oldUserr,Userr);
              Userr.StartLevel = 1;
              if (RecordUpdate(oldUserr,Userr,false)==0) then begin
              end;
            end;
          end;
        end;
      end;
    end;
  end;
// This loops sets the GlobalUserVc records as well as the actual Access Groups properly
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CompaniesRec,i,comprw);
    if (blank(comprw.TCPIP)) then begin
      if (SetCompanyCode(comprw.CompCode,false)) then begin
        ResetLoop(Accessr);
        foundf = true;
        Accessr.Code = "";
        while (LoopMain(Accessr,1,foundf)) begin
          if (Accessr.StartLevel==2) then begin
            goto LAlreadyConverted;
          end;
          ResetLoop(GlobalUserr);
          foundf2 = true;
          GlobalUserr.Code = "";
          while (LoopMain(GlobalUserr,1,foundf2)) begin
            RecordCopy(oldGlobalUserr,GlobalUserr);
            updatef = false;
            if (GlobalUserr.AccessGroup==Accessr.Code and Accessr.StartLevel==0 and GlobalUserr.StartLevel==0) then begin
              GlobalUserr.StartLevel = 1;
              updatef = true;
            end;
            rwcnt = MatRowCnt(GlobalUserr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(GlobalUserr,i,GlobalUserrw);
              if (GlobalUserrw.AccessGroup==Accessr.Code and Accessr.StartLevel==0 and GlobalUserrw.StartLevel==0) then begin
                GlobalUserrw.StartLevel = 1;
                updatef = true;
                MatRowPut(GlobalUserr,i,GlobalUserrw);
              end;
            end;
            if (updatef) then begin
              if (RecordUpdate(oldGlobalUserr,GlobalUserr,false)==0) then begin
              end;
            end;
          end;
          RecordCopy(oldAccessr,Accessr);
          Accessr.StartLevel = 2;
          if (RecordUpdate(oldAccessr,Accessr,false)==0) then begin
          end;
        end;
      end;
    end;
  end;
LAlreadyConverted:;
  ResetCompany(oldcomp);
  return;
end;

global
updating procedure ApplicationImportCompleted(Boolean textbackup,Boolean accesschanged)
begin
  if (textbackup) then begin
    if (accesschanged) Then begin
      UpdateOldAcceeGroups;
    end;
  end;
//  OnApplicationStartupComplete;
  return;
end;

global
function Boolean IsOffice(Boolean testf)
BEGIN
  Integer ProgramType;
  Boolean res;

  res = !testf;
  ProgramType = GetProgramMode;

  if (ProgramType==4) then begin res = testf; end;
  if (ProgramType==7) then begin res = testf; end;
  if (ProgramType==8) then begin res = testf; end;
  if (ProgramType==9) then begin res = testf; end;
  IsOffice = res;
  RETURN;
END;